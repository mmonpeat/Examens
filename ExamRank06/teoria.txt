https://old.chuidiang.org/clinux/sockets/sockets_simp.php
detalles del servidor

Funcions:
1.socket() -> dona l'extrem d'una connexió lliure, i retorna un fd soccket descriptor, cal tancar close(fdsock)
2.bind()   -> lliga el socket a una IP/port local
3.listen() -> Fa que el socket esperi a rebre connexions
4.accept() -> Accepta una connexió entrant. Retorna el fd per parlar amb el client. (ultima var es socklen_t len)

1. socket <unistd.h> o <sys/socket.h>

  	int sockfd = socket(domain, type, protocol); //socket(AF_INET, SOCK_STREAM, 0);
  	
	domain -> domini, tipus d'adreca per comunicar
		AF_INET: IPv4, adreces com 127.0.0.1, 192.168.1.5, etc.
		AF_INET6: IPv6 (adreces com ::1)
		AF_UNIX: sockets locals (fitxers al sistema)
	type -> tipus de comunicació
		SOCK_STREAM: connexió orientada, necessites conctar-te abans d'enviar dades
		SOCK_DGRAM: comunicació sense connexió, fa servir UDP
		SOCK_RAW: accés brut a IP(poc comú, baix nivell)
	protocol -> habitualment 0
		En la gran majoria de casos, posem 0 i el sistema operatiu tria el protocol per defecte:
			- Si has posat AF_INET + SOCK_STREAM → tria automàticament TCP // protocol bassat en connexions, mes fiable, menys rapid
			- Si has posat AF_INET + SOCK_DGRAM → tria automàticament UDP //no conexxions, mes rapid, menys fiable
			Estas son las principales diferencias entre el TCP y el UDP:

			Tipo de conexión
				TCP: Requiere una conexión establecida antes de transmitir datos
				UDP: No se necesita conexión para iniciar y finalizar una transferencia de datos

			Secuencia de datos
				TCP: Puede secuenciar datos (enviar en un orden específico)
				UDP: No puede secuenciar u ordenar datos

			Retransmisión de datos
				TCP: Puede retransmitir datos si no llegan los paquetes
				UDP: Sin retransmisión de datos. Los datos perdidos no se pueden recuperar

			Entrega
				TCP: La entrega está garantizada
				UDP: La entrega no está garantizada

			Comprobar si hay errores
				TCP: Una exhaustiva comprobación de errores garantiza que los datos lleguen en buen estado
				UDP: La comprobación de errores cubre los aspectos básicos, pero puede que no evite todos los errores

			Emisiones	
				TCP: No es compatible
				UDP: Sí es compatible

			Velocidad
				TCP: Lenta, pero entrega los datos completos
				UDP: Rápida, pero existe el riesgo de que los datos se entreguen incompletos

	Gestiones amb: bind, listen, accept, connect, send, recv, etc...
   1.1 Tanca amb close(sockfd); <unistd.h>

2. bind <sys/socket.h>

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

Exemple:
struct sockaddr_in serv_addr;
serv_addr.sin_family = AF_INET;
serv_addr.sin_port = htons(8080); // port 8080
serv_addr.sin_addr.s_addr = INADDR_ANY; // qualsevol IP local

bind(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));


3. listen <sys/socket.h>
Indica que vols rebre connexions (servidor). Converteix el socket en mode passiu: espera connexions entrants.
Indiques quantes connexions poden estar en cua d’espera (amb backlog).

int listen(int sockfd, int backlog);
listen(sockfd, SOMAXCONN); // "Deixa'm escoltar el màxim de connexions que puguis aguantar."
SOMAXCONN és una constant que diu "el màxim nombre de connexions pendents" que la teva listen() pot acceptar.
Exemple pràctic:
Si arriben 300 connexions gairebé al mateix temps:
	Si el sistema té SOMAXCONN = 128, les primeres 128 entraran a la cua.
	Les altres 172 probablement seran rebutjades.

4. accept <sys/socket.h>
Accepta una connexió entrant d'un client. Retorna un nou file descriptor per parlar amb aquell client.
El sockfd original continua escoltant (pots fer més accept() després).
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

Exemple:
struct sockaddr_in client_addr;
socklen_t client_len = sizeof(client_addr);

int clientfd = accept(sockfd, (struct sockaddr*)&client_addr, &client_len);




sockaddr_in

FD_ZERO
FD_SET
FD_ISSET
FD_CLR

Four macros are provided to manipulate the sets. FD_ZERO() clears a set. FD_SET() and FD_CLR() respectively add and remove a given file descriptor from a set. FD_ISSET() tests to see if a file descriptor is part of the set; this is useful after select() returns. 


//no pots declarar nmacros ni llibreria (#define)

//arg != 2 -> retorna Wrong num arg exit(1)
//si socket, bind, listen va malament -> retona fatal eror exit(1)
//si no pots guardar mem -> retorna fatal error exit(1)
//non bloking bind
//bind i socket en localhost

//si el client no llegeix el msg NO el pots desconectar

//el fd que rebs del socket (crec) ha d'estar preparat per fer recv o send per bloquejar, si select no s'ha cridat abans del recv o send. pero si el select esta abans del recv o send no boqueja res. ????

// client té id, el primer client id = 0, segon cli id = 1, ... 
// mgs s'envia a tos els clients conectats al servidor "server: client %d just arrived\n" %d es subtitues per el id del client, 0, 1, 2
// clients han de poder enviar msg al seerver, no chal check que s'envia
// msg pot tenir varis \n, devant de cada linea ha d'anar client %d
// client id = 3 es deconecta del servidor s'envia un msg a tots els clients conectats al servidor : "server: client %d just left\n"

// send utilitzar nomes quan el socket esta connectat. send( no te flags com args) pero write si.

//macros:
	//FD_ZERO() --> nateja el conjunt (no nateja el fd)
	//DF_SET() --> afegeix el fd al conjunt en el que hi ha altres clients
	//FD_CLR() --> elimina el fd del conjunt
	//FD_ISSET() --> mira si un fd es part del set(conjunt) al enviar msg puc fer un loop del per conprovar si es part del set i enviar msg sino hoo es surt del loop ino envia res pero seguiria en el loop del set, de socketfd. util despres de selects() ns com va exactament

//#include <sys/socket.h>
//main(ac, av)
//check num arg != 2 -> retorna Wrong num arg exit(1)
//fdsocket = socket() AF_INET 127.0.0.1 SOCK_STREAM, 0 pero tria automaticament TCP, segons les deciscions de sock stream
//bind() .sin_addr.s_addr(atoi (port)) non-blocking all ip. si error fatal err exit 1
//loop infinit
	//listen(sockfd, buffer(num connex que aguanti)) o SOMAXCONN
	//si no funciona alguna fatal error
	//pots usar send i recv (ns que com suposso send per enviar msg, recv ns)
	//accept() i cres el sockaddr_in client abans
	//FD_ZERO() natejar set potser hauria de ser abans loop????
	//if ( !FD_ISSET() fdsocket) no es part dels set
		//FD_SET () affegeix al set
		//enviar msg al grup de "server: client %d just arrived\n" 
		//fer funció send msg == > loop (fd_isset( comprovar tots i enviar als que estiguin)
		//poder enviar msg generals amb funcio send_msg
		// msg pot tenir varis \n, devant de cada linea ha d'anar client %d
	//else if ha marxat o vol maxar desconectar -lo com se que marxa si fa exit o control c?? per borrar-lo faig FD_CLR()
		//s'enviaa a tots els clients "server: client %d just left\n"
//close de sdsocket
//return (0);



#include <errno.h>
#include <netdb.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define MAX_CLI 2000
#define MAX_BUF 1000000

typedef struct s_client {
	int id;
	char msg[MAX_BUF];
} t_client;

t_client all[MAX_CLI];
fd_set rd, wr, cur;
char str[MAX_BUF + 100], rec[MAX_BUF];

int sockfd = -1, gid = 0, maxfd = -1;

void	err(char *msg)
{
	if (!msg)
		write(2, "Fatal error\n", strlen("Fatal error\n"));
	else
		write(2, msg, strlen(msg));
	if (sockfd != -1)
		close(sockfd);
	exit(1);
}

void	send_all(int except)
{
	for (int fd = 0; fd <= maxfd; fd++){
		if (FD_ISSET(fd, &wr) && fd != except)
			send(fd, str, strlen(str), 0);
	}
}

int main(int ac, char **av) {
	int connfd = -1;
	struct sockaddr_in servaddr; 
	sockfd = -1;
	gid = 0;
	
	if (ac != 2)
		err("Wrong number of arguments\n");

	// socket create and verification 
	sockfd = socket(AF_INET, SOCK_STREAM, 0); 
	if (sockfd == -1)
		err(NULL);
	bzero(&servaddr, sizeof(servaddr)); 
	
	FD_ZERO(&cur);
	FD_SET(sockfd, &cur);
	maxfd = sockfd;
	// assign IP, PORT 
	servaddr.sin_family = AF_INET; 
	servaddr.sin_addr.s_addr = htonl(2130706433); //127.0.0.1
	servaddr.sin_port = htons(atoi(av[1])); 
  
	memset(all, 0, sizeof(all));
	// Binding newly created socket to given IP and verification 
	if ((bind(sockfd, (const struct sockaddr *)&servaddr, sizeof(servaddr))) != 0)
		err(NULL);
	if (listen(sockfd, 100) != 0) 
		err(NULL);
	
	while (1) {
		rd = wr = cur;
		if (select(maxfd + 1, &rd, &wr, 0, 0) <= 0)
			continue ;
		for (int fd = 0; fd <= maxfd; fd++) {

			if (!FD_ISSET(fd, &rd)) 
				continue ;
			if (fd == sockfd) {
				struct sockaddr_in cli; 	

				socklen_t len;
			    len = sizeof(cli);
				bzero(&cli, sizeof(cli));
				connfd = accept(sockfd, (struct sockaddr *)&cli, &len);
				if (connfd < 0) 
					continue ;
				all[connfd].id = gid;
				gid++;
				if (maxfd < connfd)
					maxfd = connfd;
				FD_SET(connfd, &cur);
				sprintf(str, "server: client %d just arrived\n", all[connfd].id);
				send_all(connfd);
				break ;
			} else {
				int ret = recv(fd, rec, 100, 0);
				if (ret <= 0) {
					sprintf(str, "server: client %d just left\n", all[fd].id);
					send_all(fd);
					memset(all[fd].msg, '\0', sizeof(all[fd].msg));
					FD_CLR(fd, &cur);
					close(fd);
					break ;
				} else {
					rec[ret] = '\0';
					for (int i = 0, j = strlen(all[fd].msg); i < ret; i++, j++) {
						all[fd].msg[j] = rec[i];
						if (all[fd].msg[j] == '\n') {
							all[fd].msg[j] = '\0';
							sprintf(str, "client %d: %s\n", all[fd].id, all[fd].msg);
							send_all(fd);
							memset(all[fd].msg, '\0', sizeof(all[fd].msg));
							j = -1;
						}
					}
				}


			}
		}
	}
	return (0);
}


